* JS Quest
** What is this?
   JS Quest is an attempt to solve the age-old question -- which Javascript development stack is better? Okay, not really. The answer to that question is and always has been: whichever one helps you ship quality software quickly. But trying to highlight the salient differences between stacks is tricky. Too many articles, blog posts and forum discussion often focus too much on the individual feature list of a given stack and less on the experience of working within each stack day-to-day. There is also the problem of reference applications (I'm looking at you, TodoApp) which provide code samples in each stack, but doesn't provide a good reference for real world software development.

   JS Quest is an attempt to journal the create a non-trivial (yet not too complex) application using two different development stacks: React and Angular 2. As of this writing, these are the hottest two techs in the front-end universe. By developing the same application in both of these stack in tandem, we can quickly see how each one operates given the same set of requirements, and gain an appreciation for not just what the final product looks like, but what the journey to get there involves.

** About Me
   I've been coding websites since the late 90s, and have about a decade of front-end coding under my belt. My professional career has spanned a decade, working heavily with PHP, Rails, Javascript and HTML/CSS. As javascript frameworks go, I've worked with both Backbone and Angular 1, but have yet to do any serious work with Angular 2 or React. So I'll be diving into each stack fairly green (although I've done a LOT of reading on both).


** The App
   As for what app we're building, I've settled on doing a small browser-based game, in the style of a turn-based hack and slash dungeon crawler. I chose a game because it's most likely to keep my interest longer, and I would consider myself a domain expert in playing RPGs. As the focus is really on the process and technology, the actual game engine work will be kept simple and straightforward.

   Here's a rough outline of what a user can expect:

   1. Greeted with a start page asking for their name
   2. Asked to choose from 3 basic character classes: Fighter, Rogue, Mage
   3. Will allocate some stat points to their base state, and pick some starting items for their inventory
   4. Upon entering gameplay, the player will be shown a very basic grid map of the dungeon which they may navigate
   5. As they move around, they may encounter monsters which will put them in a simple combat interface.
   6. Killing monsters rewards items and XP.

   That's it. At least to start. Through this small app, I aim to evaluate how each development stack operates when doing the following:

   - Basic rendering of stateful components
   - How app state is modeled and managed
   - How each stack works with forms and validation
   - How each stack handles browser-based URL routing
   - Ease of doing CSS animations and SVG rendering
   - Workflow for unit and e2e testing
   - Overall performance and filesize

** The Stacks
   As this is designed to be a real-world test, I won't limit myself to just the 'out-of-box' experience for either stack. My intent is to represent the most modern thinking around how developers should work with each stack. Even I know that trying to compare Angular and React is a little bit like apples and oranges. So I'll pull in additional libraries and plugins as needed, as long as I feel they represent a solid consensus for use among their respective communities. I also intend to embrace the philosophical difference in development style as well.

   For both stacks, I plan to use Firebase for data persistence. However, I do not plan to share code between the apps so as not to bias one implementation versus the other.

*** Angular 2
    - The framework is currently in pre-release, so I will start with the latest candidate and upgrade to the release version later
    - I will use the provided cli interface for generating files
    - Will use Typescript, as it comes recommended
    - Will utilize RxJs, as it's a recommended piece of Angular 2's tooling
    - Will use a reative redux implementation called @ngrx/store
    - I aim to take advantange of some functional patterns, especially when it comes to immutable data, but will also embrance Angular's more classical OO style where it makes sense

*** React
    - Using the latest version
    - Will use plain ol' redux for state management
    - Will embrace functional programming patterns as much as makes sense
    - Will use Rambda.js as my go-to functional library
    - Will use Flow for typing

*** Other Tech
    - Gulp for transpiling and bundling
    - SCSS for CSS. We'll share this code.


* Part One: Standing Up
  Before we can get started coding, we need to stand up each stack's toolset, and get builds happening. First, let's set down our folder and file structure for our React stack. We'll use a folder-by-feature structure, and files will be named after their role. For example:

  #+BEGIN_EXAMPLE
    /dist
    /src
      /ng2
      /react
        /app
        /game
          game.container.jsx
          gameMenu.component.js
          game.actions.js
          game.reducer.js
          index.js
        index.html
      /styles
    /tools
  #+END_EXAMPLE

** Setting Up React
   What did we do?
   1. Set up basic file/folder structure
   2. Setup a webpack config (using survivejs guide)
      - using webpack merge to split configs
      - using babel and babelrc to handle transpiling
      - using sass-loader
      - setup webpack dev server with hotloading
      - use npm scripts to run commands
   3. Eslint and Flow
      - installed eslint and airbnb as default (with some modifications)
      - set up flow typechecker in babel, and added flow support to webpack

   Other notes: I am not setting up React Component Hotloading here -- I'm not sure if it's something I'm really interested in at this point, so will consider setting it up later.

   Obervation: excluding webpack and css related packages, introduced 12 third-party npm DEV dependencies just for transpiling and code QA

** Setting up Angular 2
   It's certainly possible to go through the same kinds of steps I did above to setup angular. I could work with webpack, setting up loaders, generating bundles, etc. But I'm trying to stay within the silo of common practice for each development stack here. Trying to determine best practice for React will probably be a bit harder -- its community tends to embrace a multitude of tools for achieving the same goals here. I picked webpack because it seemed sufficiently popular, and represented the best thinking (at this time). Similarly, I've decided to go all-in with the Angular CLI, something that the angular team is developing and supporting. And this is really the first example where we'll probably see the most dramatic difference between these two stacks: The React world is really about using separate tools in conjunction with one another, whereas Angular is really trying to be the whole platform, providing as many capabilities as it can under a single umbrella.

   The CLI tooling is still very alpha at this point. We'll see how far we can get before it breaks down on us. But so far, so good. With a single command, I'm able to spit out a file/folder structure, a SystemJS configuration for modules, environment specific config hooks, and configuration for testing. And I already have commands to compile type script and run a dev server within any additional configuration.

   Looking at the output, the basic setup isn't too much more complex than React (especially once you ignore some of the configuration stuff -- things we'll probably need eventually in our React app). Basically, we've got a top-level app component that gets bootstrapped to the page, and it renders out sub-components in a tree. Cool.


   What I did:
   - Installed Angular CLI
   - Create a new app
   - run `ng serve`

** Building our first real component
   Okay, now that we've got the basics of a developer stack set up let's start developing! We're going to create a simple component on our page that welcomes the user and asks for them to input their name in order to start playing our game. This should be pretty straightforward.

*** Starting with React
    To start, we'll add some introductory copy to our application component, and then add a totally new component for our 'entry' form, which at this point simply asks for a user's name.

    #+BEGIN_SRC javascript
    // app.component and entry.component
    #+END_SRC

    In the Entry component, You'll notice that I've eschewed the use of a ~propTypes~ delcaration, and instead am defining my own ~Props~ type definition. This allows us to describe the shape of my component props in a way that flow will understand at check time, instead of at runtime. Additionally, I'm using the generic object typing on ~React.Component~ to enforce type checking on my props to the type I just declared. Normally, the signature would look something like `EntryForm extend React.Component<DefaultProps, Props, State>`, but for now, we only need props. In fact, I'm doing the same thing on my App component, but leaving out props as well. This means I could write my App component using the stateless functional form, but I'm just going to assume that at some point, I will want to add state in.

    Okay, that wasn't too bad. Why don't we take one more step and do something with the form? We're still pretty far away from being able to handle anything like user registration, but we can at least apply some validation to our form field to ensure we have a user's name before submitting.

    We'll provide some validation states for our username, including detecting if it's too short or missing altogether. We'll attach a handler to our form's ~onSubmit~ event, and update the component state when attempting to submit. Pretty basic, but all we need for now.

    Doing this in react went fairly smoothly. I do have a minor gripe around using Flow, though. Some things don't seem very smooth or intuitive. Maybe I'll figure these out over time, but for right now I'm a bit stumped.
    - First, I Get an error when attempting to annotate my `render()` method as returning ~React.Element~. Flowcheck passes without a problem, but the error occurs at runtime.
    - Second, while the console output is fairly decent, WebStorm messasing around flow isn't super hot. Nothing even close to the kind of output window feedback I get with Typescript.
    - Finally, while I don't need to use ~.d.ts~ files like with Typescript, I also don't get good third party completion. In addition to that, I need to manually ignore any third-party libraries that would trigger Flow checking themselves. This is all part of Flow's philosophy around having the type checker site beside JS instead of making it inclusive, like Typescript. I agree there are certain benefits to this, but ergonomically, it feels kludgy to me.

*** Angular's turn
    Okay, let's spin up a new component in our angular app with ~ng g component EntryForm~. This will create all the files neede to get started. This actually includes our component, the HTML template file, a css file (if we're using component-level css, which we're not) and a spec file for unit testing. That's actually pretty great. It even stubs out the basic code for us.

    As for developing the same logic, in an Angular, it's not a whole lot different from our React component. The most major difference is that we're relying on Angular 2's form builder to handle binding the form value to our logic, and using the out-of-the-box form validation to detect if the username is missing or the wrong length. The other differences are mostly cosmetic: we're using Angular's declarative template language as opposed to React's html-inside-javascript approach. This template is included as part of Angular's component definition object, along with the name of the element. Also, Angular doesn't really use the concepts of Props and State that React does. Instead, change detection is done automatically based on changes to our components properties. We should note however, that we used the ~@Input()~ property decorator to indicate that a given property binds to an attribute on our component element, giving it essentially the same kind of behavior as a React Prop.

*** End Part 1

    I think this is a good stopping point for now. We've done very basic setup of our app, and gotten a basic component rendering on the page.
