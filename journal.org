* JS Quest
** What is this?
   JS Quest is an attempt to solve the age-old question -- which Javascript development stack is better? Okay, not really. The answer to that question is and always has been: whichever one helps you ship quality software quickly. But trying to highlight the salient differences between stacks is tricky. Too many articles, blog posts and forum discussion often focus too much on the individual feature list of a given stack and less on the experience of working within each stack day-to-day. There is also the problem of reference applications (I'm looking at you, TodoApp) which provide code samples in each stack, but doesn't provide a good reference for real world software development.

   JS Quest is an attempt to journal the create a non-trivial (yet not too complex) application using two different development stacks: React and Angular 2. As of this writing, these are the hottest two techs in the front-end universe. By developing the same application in both of these stack in tandem, we can quickly see how each one operates given the same set of requirements, and gain an appreciation for not just what the final product looks like, but what the journey to get there involves.

** About Me
   I've been coding websites since the late 90s, and have about a decade of front-end coding under my belt. My professional career has spanned a decade, working heavily with PHP, Rails, Javascript and HTML/CSS. As javascript frameworks go, I've worked with both Backbone and Angular 1, but have yet to do any serious work with Angular 2 or React. So I'll be diving into each stack fairly green (although I've done a LOT of reading on both).


** The App
   As for what app we're building, I've settled on doing a small browser-based game, in the style of a turn-based hack and slash dungeon crawler. I chose a game because it's most likely to keep my interest longer, and I would consider myself a domain expert in playing RPGs. As the focus is really on the process and technology, the actual game engine work will be kept simple and straightforward.

   Here's a rough outline of what a user can expect:

   1. Greeted with a start page asking for their name
   2. Asked to choose from 3 basic character classes: Fighter, Rogue, Mage
   3. Will allocate some stat points to their base state, and pick some starting items for their inventory
   4. Upon entering gameplay, the player will be shown a very basic grid map of the dungeon which they may navigate
   5. As they move around, they may encounter monsters which will put them in a simple combat interface.
   6. Killing monsters rewards items and XP.

   That's it. At least to start. Through this small app, I aim to evaluate how each development stack operates when doing the following:

   - Basic rendering of stateful components
   - How app state is modeled and managed
   - How each stack works with forms and validation
   - How each stack handles browser-based URL routing
   - Ease of doing CSS animations and SVG rendering
   - Workflow for unit and e2e testing
   - Overall performance and filesize

** The Stacks
   As this is designed to be a real-world test, I won't limit myself to just the 'out-of-box' experience for either stack. My intent is to represent the most modern thinking around how developers should work with each stack. Even I know that trying to compare Angular and React is a little bit like apples and oranges. So I'll pull in additional libraries and plugins as needed, as long as I feel they represent a solid consensus for use among their respective communities. I also intend to embrace the philosophical difference in development style as well.

   For both stacks, I plan to use Firebase for data persistence. However, I do not plan to share code between the apps so as not to bias one implementation versus the other.

*** Angular 2
    - The framework is currently in pre-release, so I will start with the latest candidate and upgrade to the release version later
    - I will use the provided cli interface for generating files
    - Will use Typescript, as it comes recommended
    - Will utilize RxJs, as it's a recommended piece of Angular 2's tooling
    - Will use a reative redux implementation called @ngrx/store
    - I aim to take advantange of some functional patterns, especially when it comes to immutable data, but will also embrance Angular's more classical OO style where it makes sense

*** React
    - Using the latest version
    - Will use plain ol' redux for state management
    - Will embrace functional programming patterns as much as makes sense
    - Will use Rambda.js as my go-to functional library
    - Will use Flow for typing

*** Other Tech
    - Gulp for transpiling and bundling
    - SCSS for CSS. We'll share this code.


* Part One: Standing Up
  Before we can get started coding, we need to stand up each stack's toolset, and get builds happening. First, let's set down our folder and file structure for our React stack. We'll use a folder-by-feature structure, and files will be named after their role. For example:

  #+BEGIN_EXAMPLE
    /dist
    /src
      /ng2
      /react
        /app
        /game
          game.container.jsx
          gameMenu.component.js
          game.actions.js
          game.reducer.js
          index.js
        index.html
      /styles
    /tools
  #+END_EXAMPLE

** Setting Up React
   What did we do?
   1. Set up basic file/folder structure
   2. Setup a webpack config (using survivejs guide)
      - using webpack merge to split configs
      - using babel and babelrc to handle transpiling
      - using sass-loader
      - setup webpack dev server with hotloading
      - use npm scripts to run commands
   3. Eslint and Flow
      - installed eslint and airbnb as default (with some modifications)
      - set up flow typechecker in babel, and added flow support to webpack

   Other notes: I am not setting up React Component Hotloading here -- I'm not sure if it's something I'm really interested in, and I'm already kind of exhausted by the number of things I need to set up and configure for a reasonable developer experience. I may do this in the future.

   Obervation: excluding webpack and css related packages, introduced 12 third-party npm DEV dependencies just for transpiling and code QA

** Setting up Angular 2
   I feel like this isn't going to any less work. I'll need to install libraries, set up a webpack config, so and so forth. One benefit is that I can rely on some automation tooling here -- specficially the angular-cli. It will scaffolding my application for me -- setting up folders, config files, a sample componentn etc. It's also here where we see the first big different between Angular and React -- Angular really is trying to a fuller-stack experience, and has opinions on how we want to work. It provides me configuration stubs for environments, unit tests, end-to-end tests, typescript definition files, etc. It wants to envelop me in the bosom of frameworky-ness, whereas React provided zero guidance or help in determing how to go about adding these features. I'm sure this will probably the biggest difference between the two stacks as we progress, and we'll see if it ends up being a help or hindrance.

   Of course, not everything Angular set up for us is gonna work for exactly our scenario. For example, angular-cli provides us with configurations for using SystemJS, not webpack. It also installed it's own package.json and node_modules for us. In a pure-Angular project, this is actually pretty great and cuts down heavily on the time to get started. However because I've chosen to use webpack, and want to share a single package.json file with the both stack setups, I'll need to spend some time re-tooling the out-of-box package provided by the cli. Essentially, I'll move all depedencies up into our root package.json, write an angular-specific webpack config, and wire up the npm scripts. I'll also streamline the folder structure a little, as I don't need /src or /public folders at this level. But I think I'll end up keeping almost all the configuration and application files generated by the cli.

   What I did:
   - Got rid of package.json and node_modules
   - Moved .tsconfig, .tslint, typings, etc. up to root level
   - Copied existing webpack over, added ts-loader
   - added a vendor.ts bundle
